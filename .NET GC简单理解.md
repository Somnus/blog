### 内存分配
- 计算对象大小。
- 添加对象指针和同步索引块。
- 从内存指针处开始，分配对象内存。
- 问题：内存不能无限制增长。

### 垃圾回收
- 从应用程序实例出发，标记所有的引用对象。
- 将标记对象移动到低地址端，修正实例引用地址与内存指针。
- 问题：全内存移动对象，垃圾回收性能不高。

### 分代回收
- 将对象分代（0、1、2），对低代对象进行垃圾回收，幸存对象升级为高代对象。
- 低代对象垃圾回收也无法满足时高代对象进行垃圾回收，若2代垃圾回收后仍不满足，抛出异常。
- 问题：托管资源由CLR自动实现垃圾回收，但非托管资源无法处理。

### 终结器机制
- 非托管资源分配内存时，若对象在析构函数中编写资源释放代码，编译器根据析构函数自动生成`Object.Finalize()`方法，将该对象指针加入到终结列表。
- 垃圾回收时，若终结列表中存在该对象指针则移除，并将对象实例添加到待终结对象列表，否则触发垃圾回收。
- CLR启用高优先级后台线程，遍历执行待终结对象列表中的Finalize方法，并从队列中移除对象实例。
- 问题：非托管资源在0代无法回收，可能存在升代情况，无法及时释放资源。

### IDisposable实现
- 非托管资源对象继承`IDisposable`接口，实现`Dispose()`方法提供资源释放功能。
- 使用者调用`Dispose()`方法及时回收非托管资源，并通知CLR不必再回收该非托管资源。
- 在析构函数中调用`Dispose()`方法作为保护机制，防止因使用者未调用`Dispose()`方法，保证非托管资源能够最终释放。

### GC触发时机
- 0代超过预算时。
- 显式调用System.GC.Collect()。
- Windows报告低内存。
- AppDomain正在被卸载。
- CLR正常关闭时。
