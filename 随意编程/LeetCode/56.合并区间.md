### 题目描述
给出一个区间的集合，请合并所有重叠的区间。
- 示例 1
```
    输入: [[1,3],[2,6],[8,10],[15,18]]
    输出: [[1,6],[8,10],[15,18]]
    解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```
- 示例 2
```
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

### 实现思考
- 考虑两区间A、B关系，无非三种：包含、相交、相离，若考虑顺序则有6种情况：A包含B，A相交B，A相离B，B包含A，B相交A，B相离A。
- 那么能不能简化到三种情况来处理呢？比如A只出现在左边。
- 可以采用基于区间左边界升序排序方法，这样就可以简化到只处理包含、相交、相离3种情况。

### 处理流程
-  基于区间左边界完成数组升序排序。
- 遍历数组：若**当前区间右边界小于后继区间左边界**，直接将当前区间添加到结果数组中；否则更新后继区间的左边界为当前区间左边界，若**当前区间右边界小于后继区间右边界**，继续循环；否则更新当前区间右边界为后继区间的右边界。
- 将数组最后一个区间添加到数组中。

### 复杂度
- 时间复杂度：排序采用快速排序，时间复杂度O(nlgn)；遍历数组需要n次。则时间复杂度为O(n(lgn+1)，即O(nlgn)。
- 空间复杂度：结果数组耗费n长度空间，即为O(n)。

### C#实现

```
    public int[][] Merge(int[][] intervals)
    {
        if (intervals.Length == 0)
        {
            return intervals;
        }

        /*基于每个区间左边界完成数组排序，保证区间左边界越小的越靠近左边。*/
        intervals = intervals.OrderBy(p => p[0]).ToArray();

        /*遍历数组，比较相邻区间是否能合并。如果左区间的右边界不小于右区间的左边界，则左右区间可以合并。*/
        List<int[]> list = new List<int[]>();
        for (int i = 0; i < intervals.Length - 1; i++)
        {
            /*
            左区间的右边界不小于右区间的左边界，则区间可以合并。将右区间作为合并后结果，
            则更新右区间的左边界为左区间的左边界。
            */
            if (intervals[i][1] >= intervals[i + 1][0])
            {
                intervals[i + 1][0] = intervals[i][0];

                /*左区间的右边界不小于右区间的右边界，则右区间的右边界更新为左区间的右边界。*/
                if (intervals[i][1] >= intervals[i + 1][1])
                {
                    intervals[i + 1][1] = intervals[i][1];
                }
            }

            /*左区间的右边界小于右区间的左边界，则左区间不能与右区间合并，将左区间添加到结果数组中。*/
            else
            {
                list.Add(intervals[i]);
            }
        }
        /*将数组中最后一个元素添加到结果中。*/
        list.Add(intervals[intervals.Length - 1]);

        int[][] result = list.ToArray();
        return result;
    }
```

### go实现
```
    func merge(intervals [][]int) [][]int {
        if len(intervals) == 0 {
            return intervals
        }

        length := len(intervals)
        intervals = QuickSort(intervals, 0, length-1)

        list := [][]int{}
        for i := 0; i < length-1; i++ {
            if intervals[i][1] >= intervals[i+1][0] {
                intervals[i+1][0] = intervals[i][0]

                if intervals[i][1] >= intervals[i+1][1] {
                    intervals[i+1][1] = intervals[i][1]
                }
            } else {
                list = append(list, intervals[i])
            }
        }

        list = append(list, intervals[length-1])
        return list
    }

    func QuickSort(nums [][]int, l int, r int) [][]int {
        if l > r {
            return nums
        }

        m := l
        n := r
        v := nums[m]

        for m < n {
            for m < n && nums[n][0] >= v[0] {
                n--
            }
            if m < n {
                nums[m] = nums[n]
            }
            for m < n && nums[m][0] <= v[0] {
                m++
            }
            if m < n {
                nums[n] = nums[m]
            }
        }
        nums[m] = v

        nums = QuickSort(nums, l, m-1)
        nums = QuickSort(nums, m+1, r)

        return nums
    }
```
