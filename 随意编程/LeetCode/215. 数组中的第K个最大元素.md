### 题目描述
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

- 示例 1:
```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

- 示例 2:
```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

说明:
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

### C#实现
```
    public int FindKthLargest(int[] nums, int k, int l = 0, int r = int.MaxValue)
    {
        if (r == int.MaxValue) r = nums.Length - 1;

        int m = l, n = r, v = nums[m];
        while (m < n)
        {
            while (nums[n] <= v && m < n) n--;
            if (m < n) nums[m] = nums[n];
            while (nums[m] >= v && m < n) m++;
            if (m < n) nums[n] = nums[m];
        }
        nums[m] = v;

        if (k - 1 == m) return v;
        else if (k - 1 < m) return FindKthLargest(nums, k, l, m - 1);
        else return FindKthLargest(nums, k, m + 1, r);
    }
```

### go实现
```
    func findKthLargest(nums []int, k int) int {
        l := 0
        r := len(nums) - 1
        return QuickSort(nums, k, l, r)
    }

    func QuickSort(nums []int, k int, l int, r int) int {
        m := l
        n := r
        v := nums[m]

        for m < n {
            for m < n && nums[n] <= v {
                n--
            }
            if m < n {
                nums[m] = nums[n]
            }
            for m < n && nums[m] >= v {
                m++
            }
            if m < n {
                nums[n] = nums[m]
            }
        }
        nums[m] = v

        if k == m+1 {
            return v
        }
        if k < m+1 {
            return QuickSort(nums, k, l, m-1)
        }
        return QuickSort(nums, k, m+1, r)
    }
```